package ru.art0.finhelper.components

import java.util.Currency

import ru.art0.finhelper.models._

import scala.collection.mutable
import scala.util.Try

trait BalanceCalculator {
  def calculateBalances(records: Seq[Record]): Seq[Either[String, (Record, BalanceSnapshot)]]
}

trait BalanceCalculatorComponent {
  def balanceCalculator: BalanceCalculator
}

class BalanceCalculatorImpl extends BalanceCalculator {
  this: ConfigurationComponent =>

  override def calculateBalances(records: Seq[Record]): Seq[Either[String, (Record, BalanceSnapshot)]] = {
    val balances = new BalancesMap

    val unflattedSeq =
      for (record <- records) yield {
        Try {

          val deltas =
            Seq(
              generateDeltaOpt(record, record.srcPurse, balances).map(d => Right(d)),
              record.dstPurse.flatMap(generateDeltaOpt(record, _, balances).map(d => Right(d)))
            ).flatten

          if (record.`type` == Type.Balance) {
            balances.initPurse(record.srcPurse, record.amount, record.currency)
          } else if (record.`type` == Type.Transfer) {
            balances.subtractPurseBalance(record.srcPurse, record.amount, record.currency)
            balances.subtractPurseBalance(record.dstPurse.get, -record.amount, record.currency)
          } else {
            balances.subtractPurseBalance(record.srcPurse, record.amount, record.currency)
          }

          deltas ++ Seq(Right((record, balances.getSnapshot)))
        }.recover {
          case e => Seq(Left(e.getMessage))
        }.get
      }

    unflattedSeq.flatten
  }

  private def generateDeltaOpt(record: Record, purse: Purse, balances: BalancesMap): Option[(Record, BalanceSnapshot)] = {
    val isSrcBalance = record.srcPurse == purse
    val knownBalanceOpt = if (isSrcBalance) record.srcBalance else record.dstBalance
    val correctedAmount = if (isSrcBalance) record.amount else -record.amount

    knownBalanceOpt.fold(Option.empty[(Record, BalanceSnapshot)]) { knownBalance =>
      val deltaRecord = record.copy(
        `type` = Type.Delta,
        category = config.deltaCategories.head,
        srcPurse = purse,
        dstPurse = None,
        comment = "Autogenerated delta",
        srcBalance = None,
        dstBalance = None,
        amount = balances.getBalance(purse).fold(sys.error(s"""Unexpected purse: "${purse}" """)) { prevBalance =>
          prevBalance.amount - knownBalance - correctedAmount
        }
      )

      balances.subtractPurseBalance(purse, deltaRecord.amount, deltaRecord.currency)

      if (deltaRecord.amount != 0) {
        Some((deltaRecord, balances.getSnapshot))
      } else {
        None
      }
    }
  }



  class BalancesMap {
    val balances: mutable.Map[Purse, AmountCurrency] = mutable.Map.empty
    val bannedPurses: mutable.Set[Purse] = mutable.Set.empty

    def subtractPurseBalance(purse: Purse, difference: Long, currency: Currency): Unit = {
      getBalance(purse).fold {
        sys.error(s"""Error updating balance for purse "${purse}": purse does not have initial balance""")
      } { prevBalance =>
        if (prevBalance.currency == currency && !bannedPurses.contains(purse)) {
          balances.update(purse, AmountCurrency(prevBalance.amount - difference, prevBalance.currency))
        } else if (prevBalance.currency == currency && bannedPurses.contains(purse)) {
          sys.error(s"""Operation with purse "${purse}" was skipped as it had errors previously""")
        } else {
          bannedPurses.add(purse)
          sys.error(s"Unexpected purse currency. Expected: ${prevBalance.currency}, found: ${currency}")
        }
      }
    }

    def getBalance(purse: Purse): Option[AmountCurrency] = balances.get(purse)

    def getBannedPurses: Set[Purse] = bannedPurses.toSet

    def initPurse(purse: Purse, initialBalance: Long, currency: Currency): Unit = {
      getBalance(purse).fold {
        balances.put(purse, AmountCurrency(initialBalance, currency))
      } { _ =>
        bannedPurses.add(purse)
        sys.error(s"""Balance for purse "${purse}" has already been initialized""")
      }
    }

    def getSnapshot: BalanceSnapshot = balances.toMap
  }
}